#summary Basic tutorials for SGDK API

== Table of Content ==
 # *[#Introduction Introduction]*
 # *[#Hello_World Hello World !]*
 # *[#Input Read the joypad]*
 # *[#Tiles Tiles]*
 # _*Sprites*_ _(coming soon)_
 # _more_
 # *[#History History and changes]*
 
----
 
== Introduction ==
These several basic tutorials aim to give you the basis to start developing on the Sega Genesis / Megadrive using SGDK.

Written in C language (ASM is out of scope), you'll be able to fully understand them if you already have basic knowledge on how the Genny works.

So, before you start reading the tutorials, be sure to check and read these others documents:
 * [http://emudocs.org/Genesis/sega2f.htm Genesis Technical Overview] by Sega
 * [http://cgfm2.emuviews.com/txt/genvdp.txt Sega Genesis VDP documentation] by Charles !MacDonald
 * [http://cgfm2.emuviews.com/txt/gen-hw.txt Sega Genesis hardware notes] by Charles !MacDonald
 * Sega Genesis I/O Chip and Peripherals by Charles !MacDonald (_dead link_)

----
 
== Hello World ==

Whenever you use [UseSGDKWithCB Code::Block], [UseSGDKWithEclipse Eclipse], [HowToUseSGDK Notepad] or any other souce code editor, you need your `main` function.

{{{
int main( )
{
	return (0);
}
}}}


This function is your starting point and is automatically called on start up.

Before that, SGDK initializes several things for you  :
 * set default values for each [http://info.sonicretro.org/SCHG:VDP_Documentation/General/Registers VDP register]
 * clean Video RAM
 * load 4 default palettes : grey, red, green and blue
 * load a default font for your text print need
 * init input handling
 * reset sound and music
 * load a default sound driver ("2 channels PCM sample" driver in SGDK 0.7)

so, for basic stuff and testing, everything is ready to use!
It's so easy to call VDP, input or sprites stuff right on your main function....if you don't forget to include the `genesis.h` header!


For now, let's see how to print the infamous _*Hello World*_.

Printing on screen is a VDP task so you need to call `VDP_drawText(<your_text>, <x>, <y>)`.

Remember, x and y are in tile unit, not pixel unit with 1 tile = 8 pixels.

Ex:
{{{
#include <genesis.h>

int main()
{
	VDP_drawText("Hello World!", 10, 13);
	return (0);
}
}}}

This code is correct but not Genesis friendly : do you think we can return (and stop) a program ?

Video games repeatly update the TV screen, and it's up to you to handle things before or while a refresh.

So a more Genny Hello World is more like this :
{{{
#include <genesis.h>

int main()
{
	VDP_drawText("Hello Genny World!", 10, 13);

	while(1)
	{
		//read input
		//move sprite
		//update score
		//draw current screen (logo, start screen, settings, game, gameover, credits...)
	}
	return (0);
}
}}}

This code is correct, even if `return(0)` will never be reached.

The code inside the while loop will execute in full speed...great! but do you think the Genesis will handle so much ?

The TV screen is updated 50 (PAL) or 60 (NTSC) times per second...you have to be sync with this.

An usefull way is to wait for screen update, or vertical synchronisation.

SGDK is here to help you with the `VDP_waitVSync` func.

So, this time, you could write your first Genesis fully compliant demo.

Ex:
{{{
#include <genesis.h>

int main()
{
	VDP_drawText("Hello Genny World!", 10, 13);

	while(1)
	{
		//read input
		//move sprite
		//update score
		//draw current screen (logo, start screen, settings, game, gameover, credits...)

		//wait for screen refresh
		VDP_waitVSync();
	}
	return (0);
}
}}}
Congratulations! You're now ready to make a little more!

Download : [http://sgdk.googlecode.com/svn/wiki/files/tut1_HelloWorld.zip Sample Hello World project]

----

== Input ==

=== Basic ===
You'll now learn how to handle input from controllers

The first thing to do is to call `JOY_init()`, this will reset the handler and read informations about the connected controllers.

SGDK uses a call back function to handle input.

This way, you don't need to poll each loop the data port but to wait for you callback function to be ... calle everytime the input change (button A released, left pad pressed, ...).

Using `JOY_setEventHandler`, you had to register this callback function to be called.

It's very important to define your callback function with this signature : `void myJoyHandler( u16 joy, u16 changed, u16 state)`.

It's also good practice to always use SGDK defined constants.

Ex:
{{{
void myJoyHandler( u16 joy, u16 changed, u16 state)
{
	if (joy == JOY_1)
	{
		if (state & BUTTON_START)
		{
			//player 1 press START button
		}
		else if (changed & BUTTON_START)
		{
			//player 1 released START button	
		}
	}	
}

int main( )
{
	JOY_init();
	JOY_setEventHandler( &myJoyHandler );

	while(1)
	{
		VDP_waitVSync();
	}
	return 0;
}
}}}

Download : [http://sgdk.googlecode.com/svn/wiki/files/tut2_Input.zip Basic input project]

<wiki:comment>
=== Multipad ===

This will work for up to 4 players using a [http://www.segaretro.org/4_Way_Play EA4Way] and up to 8 players using 2 [http://www.segaretro.org/Team_Player Sega TeamPlayer].

If you plan to support multiplayers, remember to use the correct joy IDs : JOY_1/JOY_1A, JOY_1B, JOY_1C, JOY_1D, JOY2/JOY_2A, JOY_2B, JOY_2C, JOY_2D.

Of course, you must be able to detect if there is a !TeamPlayer or a EAWay connected.

There are actually 2 ways to know this :
 # throught the port (PORT_1 or PORT_2) using `JOY_isMultipad( port )`.
 {{{
This will return 0 if it's not a multiplayer mode, JOY_SUPPORT_EA4WAY for an EA4Way and JOY_SUPPORT_TEAMPLAY for... a Sega TeamPlay
}}}
 # throught the joypad itself using `JOY_getJoyID( joy )`
{{{
This will return the ID of the joy.
If (ID & JOY_SUPPORT_EA4WAY), the joypad is connected to a EA4Way
If (ID & JOY_SUPPORT_TEAMPLAY), the joypad is connected to a SegaTeam play
}}}


Ex:
{{{
void myJoyHandler( u16 joy, u16 changed, u16 state)
{
	if (joy == JOY_1B) //2nd player on multitap
	{
		if (state & BUTTON_START)
		{
			//player 3 press START button
		}
		else if (changed & BUTTON_START)
		{
			//player 3 released START button	
		}
	}	
}

int main( )
{
	JOY_init();
	JOY_setEventHandler( &myJoyHandler );

	while(1)
	{
		VDP_waitVSync();
	}
	return 0;
}
}}}


`JOY_getJoyID` gives you ever more information about the current joypad.

Actually, SGDK is able to give you the ID of
 * 3 buttons joypad (ID & *JOY_SUPPORT_3BTN*)
 * 6 buttons joypad (ID & *JOY_SUPPORT_6BTN*)
 * Sega !TeamPlayer (ID & *JOY_SUPPORT_TEAMPLAY*)
 * EA 4Way or !TeamPlayer in Extra mode (ID & *JOY_SUPPORT_EA4WAY*)
 * Sega Mouse (ID & *JOY_SUPPORT_MOUSE*)
 * Konami Justifier (ID & *JOY_SUPPORT_JUSTIFIER*)

The informations are defined on `JOY_init()` and after at least one refresh.

Ex:
{{{
int main( )
{
	JOY_init();
	VDP_waitVSync();
	
	if (JOY_getJoyID(JOY_1) & JOY_SUPPORT_JUSTIFIER)
	{
		VDP_drawText("JUSTIFIER NOT YET SUPPORTED", 10, 10);
	}

	while(1)
	{
		VDP_waitVSync();
	}
	return 0;
}
}}}

Yes, SGDK doesn't handle Justifier yet, we're working on it but it handles mouse!

=== Mouse ===

Mouse support is almost the same as joypad but you had to register another function to handle mouse move with `JOY_setMouseEventHandler`.

Similary, the signature of your callback function must be `void myMouseHandler( u16 joy, s8 xDelta, s8 yDelta, u16 buttonState)`.

Ex:
{{{
s16 mouseX=0, mouseY=0;
void myMouseHandler( u16 joy, s8 xDelta, s8 yDelta, u16 buttonState)
{
	char str[4];
	u8 mouseState;

	//move only if left pressed
	if ( buttonState & MOUSE_LEFT )
	{
		mouseX+= xDelta;
		if (mouseX<0)	mouseX = 0;

		mouseY+= yDelta;
		if (mouseY<0)	mouseY = 0;
	}
}
int main( )
{
	JOY_init();
	JOY_setEventHandler( &myJoyHandler ); //mouse button pressed is handled like a joypad, mainly to handle start
	JOY_setMouseEventHandler( &myMouseHandler );

	while(1)
	{
		VDP_waitVSync();
	}
	return 0;
}
}}}
</wiki:comment>
==== Misc ====

Some others usefull functions are available:
 * `JOY_update()` refreshes joypad status (called every screen refresh so don't call it yourself unless you really need it)
 * `JOY_readJoypad( joy )` gives you the joy1 status whenever you need it
 * `JOY_waitPressBtn()` waits for any buttons to be pressed (not directions)
 * `JOY_waitPress(joy, BUTTON_A | BUTTON_UP)` waits for wanted buttons to be pressed on specific joypad

 
 
_Note for advanced developer :_

if you ever made you're own VBlankCallback, `JOY_update()` is always called whatever you do.

----

== Tiles ==

If you read documents linked on [#Introduction first part], you should know how to write more than 'Hello World' on screen :
 * the Genny redraws 2 planes on refresh (+ a third one for the sprites)
 * each plane is filled with 8x8 pixel tile
 * each plane could be 32x32 to 128x128 tiles in memory (only up to 40x28 is visible on screen)
 * each tile could be used several times in any plane, with the same pal or not
 * each tile could be used with any of the 4 pal available
 * each tile could be drawn flipped, w/o more memory
 * a very important amout of tiles could be loaded using DMA
 
=== Basic ===
Some other data you should know :
 * one tile is made of 32bytes : 4byte per line
 * each pixel of the tile is so a 4bit value which is the color index, from 0x0 to 0xF
 * the first tile (tile 0) on VRam will be used to fill the background
 * SGDK initialize enought space on VRAM for 1310 tiles (+ 96 for the font)
 * a tile is also called a pattern or a char
 * a tile on screen isn't removed on refresh (ie no need to draw it each refresh!)
 * a pal is 16 colors wide

So, the step to draw a tile on screen are the following
 # load the tile on VRAM (we don't bother about DMA yet)
 # load its pal (if not already loaded)
 # plot it on the selected plane, at (x,y) with the wanted pal

But first, we need a tile !

Several tools were made by the communauty ([http://www.pascalorama.com/article.php?news=28&cat=21 Genitile], [http://gendev.spritesmind.net/page-b2t.html B2T], [http://gendev.spritesmind.net/page-genres.html GenRes], [http://uberleethackerforce.deepgeek.us/prods.html Mega-Happy-Sprite]
...) let you convert a 16 color bitmap in Genny's tile and pal.

But, to learn, we'll first make it the hard way : pure C Array !

{{{
const u32 tile[8]=
{
		0x00111100,
		0x01144110,
		0x11244211,
		0x11244211,
		0x11222211,
		0x11222211,
		0x01122110,
		0x00111100
};
}}}

Our tile is only made of color 0, 1, 2 & 4.

Now, just follow the steps

{{{
	// ... code
	
	//we load our unique tile data at position 1 on VRAM
	VDP_loadTileData( (const u32 *)tile, 1, 1, 0); 
	
	//we'll use one of the pre-loaded pal for now
	
	//write our tile 1 on plane A at (5,5) with pal 0
	VDP_setTileMap(APLAN, 1, 5, 5);
	
	// ... code
	
	while(1)
	{
		// ... code
		VDP_waitVSync();
	}
	
}}}

The tile is so drawn on screen using some fade of grey...but what about flipping and pal ?

The 2nd argument of `VDP_setTileMap` func could be more than only the tile index.

It is, in fact, the tile properties : pal index, priority, vflipping, hflipping and tile index.

So, to write it flipped green on B plane, you could write

{{{
	// ... code
	
	//PAL2 = green pal
	// 0 = low priority
	// 1 = vflip
	// 0 = no hflip
	// 1 = tile 1
	VDP_setTileMap(BPLAN, TILE_ATTR_FULL(PAL2, 0, 1, 0, 1), 6, 5);
	
	// ... code
}}}


It's now time to talk about the priority flag.

This flag tell which plane is behind the others (even more complex if you add sprites !).

A powerful feature of the Genny is to let the developper define the planes order at the tile level.

It means a tile on A plane could be in front of a tile on B plane at (x,y) and inverse the priority at (n,m).

You could easily see the power of this when scrolling planes at different speed for example.

{{{
	// ... code
	
	// the same tile is drawn on the 2 plane but with different pal and priority...which one is in front ?
	VDP_setTileMap(APLAN, TILE_ATTR_FULL(PAL1, 1, 0, 0, 1), 7, 7);
	VDP_setTileMap(BPLAN, TILE_ATTR_FULL(PAL2, 0, 0, 0, 1), 7, 7);
	VDP_setTileMap(APLAN, TILE_ATTR_FULL(PAL1, 0, 0, 0, 1), 8, 7);
	VDP_setTileMap(BPLAN, TILE_ATTR_FULL(PAL2, 1, 0, 0, 1), 8, 7);
	
	// ... code
}}}

Here, at (7,7) plane A is in front of plane B but, at (8,7), plane B is in front of plane A.
 

But, what will happen if the planes get the same priority ?

The default order is kept : plane A is in front of plane B.


=== Fill ===

To fill a screen, you have to draw each tile one by one !

Very boring but, hopefully, SGDK came to the rescue with `VDP_fillTileMapRect`.

{{{
	// ... code
	
	// fill a 8x8 square of blue tile at (12,12)
	VDP_fillTileMapRect(BPLAN, TILE_ATTR_FULL(PAL3, 0, 0, 0, TILE1), 12, 12, 8, 8);
	
	// ... code
}}}


Download : [http://sgdk.googlecode.com/svn/wiki/files/tut3_TilesBasic.zip Basic tiles project]


=== Multi tile ===

It will be hard to make a game using one and unique tile.

We'll try now to draw this moon on screen

http://sgdk.googlecode.com/svn/wiki/pictures/tutTile-blue-moon.jpg

2 important things to check before to continue
 # the bitmap size should be 8 pixel aligned (ie : 64x32 is good where 67x31 isn't)
 # the bitmap sould be a 16 colors, 4 bits/pixel BMP... be careful about this, some image editor save 256 colors BMP with only the first 16 colors filled
 
SGDK is able to handle several raw files if they are copied in a `res/` subfolder.

*WARNING* : you need at least SGDK v0.7b since there is a bug on pal support in previous versions

_Don't be afraid by the warning messages, it's a little bug on the extractor_

If you copy your bitmap on this folder, SGDK will produce a `name_of_bmp_file.h` and a `name_of_bmp_file.o`

`name_of_bmp_file.o` is the object form of your bitmap.

`name_of_bmp_file.h` let you access the bitmap raw data.

so, including `name_of_bmp_file.h`, you could load the bitmap on VRAM this way

{{{
#include "moon.h"

int main( )
{
	// get the image width (in pixel) ==> should be 8pix aligned
	u16 w = moon[0];
	// get the image height (in pixel)  ==> should be 8px aligned
	u16 h = moon[1];

	// get the palette at moon[2 to 17]
	VDP_setPalette(PAL1, &moon[2]);

	
	// load bitmap data at moon[18....] in VRAM
	// w/8 = width in tiles we want to load
	// h/8 = height in tile we want to load
	// w/8 = width in tiles of the bitamp
	// the 3rd arg is needed because you could load only a part of the bitmap if you want but SGDK needs the width as reference
	VDP_loadBMPTileData((u32*) &moon[18], 1, w / 8, h / 8, w/8 );


	while(1)
	{
		VDP_waitVSync();
	}
	return 0;
}
}}}

For this moon, you have 8x8 tiles loaded.

You could draw them by hand using `VDP_setTileMap` but it's boring and, as usual when it's a boring process, SGDK has a magical function for it : `VDP_fillTileMapRectInc`.

This function draw FROM the tile index in argument to the last needed to fill the rect wanted.

{{{
	// draw the moon at (12,12)
	VDP_fillTileMapRectInc(BPLAN, TILE_ATTR_FULL(PAL1, 0, 0, 0, 1), 12, 12, w / 8, h / 8);
}}}


Download : [http://sgdk.googlecode.com/svn/wiki/files/tut3_TilesBitmap.zip Bitmap tiles project]

=== Compression ===

If you use a large amount of tiles, we strongly suggest you to compress them (using RLE, huffman, ...).

SGDK doesn't include (yet?) a method to load compressed bitmap data so it's up to you to make your own (de)compression algorithm.

Check if the tool you use could export compressed data too.

=== Misc ===

One useful way to test your tile engine is throught Gens KMod.

You could explore the VRAM and trace any issue.

http://sgdk.googlecode.com/svn/wiki/pictures/tutTile_Kmod.jpg

----

== History ==

31 January 2011 - Tiles part
 * Basic tiles
 * Tiles from bitmap
 
26 January 2011 - Initial release
 * Introduction
 * Hello world sample
 * Basic input
