<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>sgdk: sys.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">sgdk</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('sys_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sys.h File Reference</div>  </div>
</div>
<div class="contents">

<p>Entry point unit / Interrupt callback / System.  
<a href="#details">More...</a></p>

<p><a href="sys_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_o_m_header.html">ROMHeader</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d76844d10815e3eccda073e59a67577"></a><!-- doxytag: member="sys.h::PROCESS_PALETTE_FADING" ref="a3d76844d10815e3eccda073e59a67577" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PROCESS_PALETTE_FADING</b>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a609d87796fe3401e7583e05c78e1c52b"></a><!-- doxytag: member="sys.h::PROCESS_BITMAP_TASK" ref="a609d87796fe3401e7583e05c78e1c52b" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PROCESS_BITMAP_TASK</b>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8e620a9f64f7b8f200b5fe17b7287c8"></a><!-- doxytag: member="sys.h::PROCESS_DMA_TASK" ref="aa8e620a9f64f7b8f200b5fe17b7287c8" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PROCESS_DMA_TASK</b>&#160;&#160;&#160;(1 &lt;&lt; 2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab363519476a47ed0698781533ab506d0"></a><!-- doxytag: member="sys.h::PROCESS_XGM_TASK" ref="ab363519476a47ed0698781533ab506d0" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PROCESS_XGM_TASK</b>&#160;&#160;&#160;(1 &lt;&lt; 3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1235f3666cfcb521ae7b5c16bd3266ce"></a><!-- doxytag: member="sys.h::PROCESS_VDP_SCROLL_TASK" ref="a1235f3666cfcb521ae7b5c16bd3266ce" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PROCESS_VDP_SCROLL_TASK</b>&#160;&#160;&#160;(1 &lt;&lt; 4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8edff88167efee1ab0d34628f10001e"></a><!-- doxytag: member="sys.h::ROM_ALIGN_BIT" ref="ac8edff88167efee1ab0d34628f10001e" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ROM_ALIGN_BIT</b>&#160;&#160;&#160;17</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac970084db3ba9b9b3a6595faef7f74ee"></a><!-- doxytag: member="sys.h::ROM_ALIGN" ref="ac970084db3ba9b9b3a6595faef7f74ee" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ROM_ALIGN</b>&#160;&#160;&#160;(1 &lt;&lt; ROM_ALIGN_BIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73bff01b811dbbdf0dd18103ac556b02"></a><!-- doxytag: member="sys.h::ROM_ALIGN_MASK" ref="a73bff01b811dbbdf0dd18103ac556b02" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ROM_ALIGN_MASK</b>&#160;&#160;&#160;(ROM_ALIGN - 1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a385704542a5aed01d5f66618e0caff71"></a><!-- doxytag: member="sys.h::ROM_START" ref="a385704542a5aed01d5f66618e0caff71" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ROM_START</b>&#160;&#160;&#160;ROM</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fafdaede51f1a2092840264d1776522"></a><!-- doxytag: member="sys.h::ROM_END" ref="a1fafdaede51f1a2092840264d1776522" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ROM_END</b>&#160;&#160;&#160;(((<a class="el" href="types_8h.html#a449a74b72ed931d627eca7efcc6f8c9d">u32</a>) &amp;_stext) + ((<a class="el" href="types_8h.html#a449a74b72ed931d627eca7efcc6f8c9d">u32</a>) &amp;_sdata))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9e53d1418399b36953a40395ac1384d"></a><!-- doxytag: member="sys.h::ROM_SIZE" ref="ad9e53d1418399b36953a40395ac1384d" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ROM_SIZE</b>&#160;&#160;&#160;((ROM_END + ROM_ALIGN_MASK) &amp; (~ROM_ALIGN_MASK))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a957651d3142d741ae29e0ea3f0969997"></a><!-- doxytag: member="sys.h::HINTERRUPT_CALLBACK" ref="a957651d3142d741ae29e0ea3f0969997" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HINTERRUPT_CALLBACK</b>&#160;&#160;&#160;__attribute__ ((interrupt)) void</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#ab430c96f46851da92937d54104c6635e">VBlankProcessTime</a> { <b>IMMEDIATELY</b>, 
<a class="el" href="sys_8h.html#ab430c96f46851da92937d54104c6635ea4b81f850a51345d4a4df71211fa3d5bc">ON_VBLANK</a>, 
<a class="el" href="sys_8h.html#ab430c96f46851da92937d54104c6635eaec4a09e18e25c55cc5758202868234d5">ON_VBLANK_START</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define at which period to do VBlank process (see <a class="el" href="sys_8h.html#a753b47efe923d70d7c897a5b433efdc4" title="Wait for start of VBlank and do all the VBlank processing (DMA transfers, XGM driver tempo...">SYS_doVBlankProcess()</a> method)  <a href="sys_8h.html#ab430c96f46851da92937d54104c6635e">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a6433ce830019a6fc97d9b1fed7b62d4d">SYS_assertReset</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert reset.  <a href="#a6433ce830019a6fc97d9b1fed7b62d4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#aa5782fca78b4f2efe6c48e4103c51509">SYS_reset</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Soft reset.  <a href="#aa5782fca78b4f2efe6c48e4103c51509"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a5b65c43acff239a7ae711f8b14cbed0e">SYS_hardReset</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard reset.  <a href="#a5b65c43acff239a7ae711f8b14cbed0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a753b47efe923d70d7c897a5b433efdc4">SYS_doVBlankProcess</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for start of VBlank and do all the VBlank processing (DMA transfers, XGM driver tempo, Joypad pooling..)  <a href="#a753b47efe923d70d7c897a5b433efdc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#abb71a9d2233dd1dda79dfeccb74c8ab5">SYS_doVBlankProcessEx</a> (<a class="el" href="sys_8h.html#ab430c96f46851da92937d54104c6635e">VBlankProcessTime</a> processTime)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Do all the VBlank processing (DMA transfers, XGM driver tempo, Joypad pooling..)  <a href="#abb71a9d2233dd1dda79dfeccb74c8ab5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#aadf3f1f08c7b856a150e91d8068e9d04">SYS_nextFrame</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">End the current frame (alias for <a class="el" href="sys_8h.html#a753b47efe923d70d7c897a5b433efdc4" title="Wait for start of VBlank and do all the VBlank processing (DMA transfers, XGM driver tempo...">SYS_doVBlankProcess(void)</a>).  <a href="#aadf3f1f08c7b856a150e91d8068e9d04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#af8f4c24b1cce2cef131d0346b4fa6d5f">SYS_getInterruptMaskLevel</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current interrupt mask level.  <a href="#af8f4c24b1cce2cef131d0346b4fa6d5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a810cfc8509ce88565fc002240539f9db">SYS_setInterruptMaskLevel</a> (<a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a> value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt mask level.  <a href="#a810cfc8509ce88565fc002240539f9db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a00419727f141d248e171b4f66320bf2c">SYS_getAndSetInterruptMaskLevel</a> (<a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a> value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the interrupt mask level to given value and return previous level.  <a href="#a00419727f141d248e171b4f66320bf2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a463232079760831964d6231a7880dfa7">SYS_disableInts</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable interrupts (Vertical, Horizontal and External).  <a href="#a463232079760831964d6231a7880dfa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a3a832a0d05ffe4e856ebc3dbd53438e2">SYS_enableInts</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-enable interrupts (Vertical, Horizontal and External).  <a href="#a3a832a0d05ffe4e856ebc3dbd53438e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#aa8dccd62df36a5d1b54eb169053fbcaf">SYS_setVBlankCallback</a> (VoidCallback *CB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set user 'Vertical Blank' callback method.  <a href="#aa8dccd62df36a5d1b54eb169053fbcaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#abc2725f07baaf70c775935a3878343a1">SYS_setVIntCallback</a> (VoidCallback *CB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 'Vertical Interrupt' callback method, prefer <a class="el" href="sys_8h.html#aa8dccd62df36a5d1b54eb169053fbcaf" title="Set user &#39;Vertical Blank&#39; callback method.">SYS_setVBlankCallback</a>(..) when possible.  <a href="#abc2725f07baaf70c775935a3878343a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a6804e7c1dab303971561691d0caf0d49">SYS_setHIntCallback</a> (VoidCallback *CB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 'Horizontal Interrupt' callback method (need to be prefixed by HINTERRUPT_CALLBACK).  <a href="#a6804e7c1dab303971561691d0caf0d49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#aa189958e09ac6e0b5ca069cd6a99e856">SYS_setExtIntCallback</a> (VoidCallback *CB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set External interrupt callback method.  <a href="#aa189958e09ac6e0b5ca069cd6a99e856"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#adb5ccb95eb2b322ea1fb80d6871b82bc">SYS_isInVInt</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if we are in the V-Interrupt process.  <a href="#adb5ccb95eb2b322ea1fb80d6871b82bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#aff9750590a3aa05ba1dc9efa4529b00f">SYS_isNTSC</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return != 0 if we are on a NTSC system.  <a href="#aff9750590a3aa05ba1dc9efa4529b00f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a7f0520edbbd126d55d6840a7c9c474e1">SYS_isPAL</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return != 0 if we are on a PAL system.  <a href="#a7f0520edbbd126d55d6840a7c9c474e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a449a74b72ed931d627eca7efcc6f8c9d">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a876843c56b6ea85412f677ac34826265">SYS_getFPS</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of Frame Per Second.  <a href="#a876843c56b6ea85412f677ac34826265"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7470dd593b8647d2e9fcb1e94b1025c9">fix32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a8efead9cf4b059b28449895f2ad0e656">SYS_getFPSAsFloat</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of Frame Per Second (fix32 form).  <a href="#a8efead9cf4b059b28449895f2ad0e656"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a8d25b812d3e84e3a61a317f2494332cd">SYS_getCPULoad</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an estimation of CPU frame load (in %)  <a href="#a8d25b812d3e84e3a61a317f2494332cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#ac6cb85c35f5fac38c07c786024e15f4d">SYS_getShowFrameLoad</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if frame load is currently displayed, FALSE otherwise.  <a href="#ac6cb85c35f5fac38c07c786024e15f4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a7e50c065da5277fd1bf18056f89cb960">SYS_showFrameLoad</a> (<a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a> mean)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Show a cursor indicating current frame load level in scanline (top = 0% load, bottom = 100% load)  <a href="#a7e50c065da5277fd1bf18056f89cb960"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#ab3b5aebd08e6d8d083de6b3b53badacd">SYS_hideFrameLoad</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hide the frame load cursor previously enabled using <a class="el" href="sys_8h.html#a7e50c065da5277fd1bf18056f89cb960" title="Show a cursor indicating current frame load level in scanline (top = 0% load, bottom = 100% load)...">SYS_showFrameLoad()</a> method.  <a href="#ab3b5aebd08e6d8d083de6b3b53badacd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a839015e76f97c2943ede31eb2ea7e41d"></a><!-- doxytag: member="sys.h::SYS_computeChecksum" ref="a839015e76f97c2943ede31eb2ea7e41d" args="(void)" -->
<a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a839015e76f97c2943ede31eb2ea7e41d">SYS_computeChecksum</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes full ROM checksum and return it.<br/>
 The checksum is a custom fast 32 bit checksum converted to 16 bit at end. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa911fc0a8b9becca532a2d46381efe0"></a><!-- doxytag: member="sys.h::SYS_isChecksumOk" ref="afa911fc0a8b9becca532a2d46381efe0" args="(void)" -->
<a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#afa911fc0a8b9becca532a2d46381efe0">SYS_isChecksumOk</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if ROM checksum is ok (correspond to rom_head.checksum field) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#abf16e3876c8375abef07da14d96d7ba9">SYS_die</a> (char *err)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Die with the specified error message.<br/>
 Program execution is interrupted.  <a href="#abf16e3876c8375abef07da14d96d7ba9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11102c9d54d2e671587775142039ff26"></a><!-- doxytag: member="sys.h::rom_header" ref="a11102c9d54d2e671587775142039ff26" args="" -->
const <a class="el" href="struct_r_o_m_header.html">ROMHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rom_header</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83dac9716db2f226708a13c668e9e5fd"></a><!-- doxytag: member="sys.h::_stext" ref="a83dac9716db2f226708a13c668e9e5fd" args="" -->
<a class="el" href="types_8h.html#a449a74b72ed931d627eca7efcc6f8c9d">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_stext</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8920421b103c037ae873b246bdfee34"></a><!-- doxytag: member="sys.h::_sdata" ref="ad8920421b103c037ae873b246bdfee34" args="" -->
<a class="el" href="types_8h.html#a449a74b72ed931d627eca7efcc6f8c9d">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_sdata</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VoidCallback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a61bbd6b4f07f82f9bd611ef58721eef1">busErrorCB</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bus error interrupt callback.  <a href="#a61bbd6b4f07f82f9bd611ef58721eef1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VoidCallback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#ab41d8358de9da304b45a9cd847cb03cd">addressErrorCB</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Address error interrupt callback.  <a href="#ab41d8358de9da304b45a9cd847cb03cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VoidCallback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#ac850e8b90e9b259160ffb52963981df8">illegalInstCB</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Illegal instruction exception callback.  <a href="#ac850e8b90e9b259160ffb52963981df8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VoidCallback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a182faeee80f45228cb08a9a934a293d3">zeroDivideCB</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Division by zero exception callback.  <a href="#a182faeee80f45228cb08a9a934a293d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VoidCallback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#abf6b1b9a2bfea27af8214110dc17a46b">chkInstCB</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">CHK instruction interrupt callback.  <a href="#abf6b1b9a2bfea27af8214110dc17a46b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VoidCallback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#ac391fc51fd8d14f9fa49df15659dfe82">trapvInstCB</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TRAPV instruction interrupt callback.  <a href="#ac391fc51fd8d14f9fa49df15659dfe82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VoidCallback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a5038c44f538391d4f31be0a59c7c3462">privilegeViolationCB</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Privilege violation exception callback.  <a href="#a5038c44f538391d4f31be0a59c7c3462"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VoidCallback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#ab2ad43e595f0a19f7a8431dc2a7d8de5">traceCB</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace interrupt callback.  <a href="#ab2ad43e595f0a19f7a8431dc2a7d8de5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VoidCallback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a202e800a4fe6f8f9072d8a22847bb5d0">line1x1xCB</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_line.html" title="Line definition.">Line</a> 1x1x exception callback.  <a href="#a202e800a4fe6f8f9072d8a22847bb5d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VoidCallback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#af2a592696b5e90e63bf969d555d66cbf">errorExceptionCB</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Error exception callback.  <a href="#af2a592696b5e90e63bf969d555d66cbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VoidCallback *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys_8h.html#a46c6198d4926288b16793833d2ddc89a">intCB</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Level interrupt callback.  <a href="#a46c6198d4926288b16793833d2ddc89a"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Entry point unit / Interrupt callback / System. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Stephane Dallongeville </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>08/2011</dd></dl>
<p>This unit contains SGDK initialization / reset methods, IRQ callbacks and others system stuff. </p>
</div><hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ab430c96f46851da92937d54104c6635e"></a><!-- doxytag: member="sys.h::VBlankProcessTime" ref="ab430c96f46851da92937d54104c6635e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sys_8h.html#ab430c96f46851da92937d54104c6635e">VBlankProcessTime</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define at which period to do VBlank process (see <a class="el" href="sys_8h.html#a753b47efe923d70d7c897a5b433efdc4" title="Wait for start of VBlank and do all the VBlank processing (DMA transfers, XGM driver tempo...">SYS_doVBlankProcess()</a> method) </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ab430c96f46851da92937d54104c6635ea4b81f850a51345d4a4df71211fa3d5bc"></a><!-- doxytag: member="ON_VBLANK" ref="ab430c96f46851da92937d54104c6635ea4b81f850a51345d4a4df71211fa3d5bc" args="" -->ON_VBLANK</em>&nbsp;</td><td>
<p>Start VBlank process immediately whatever we are in blanking period or not </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab430c96f46851da92937d54104c6635eaec4a09e18e25c55cc5758202868234d5"></a><!-- doxytag: member="ON_VBLANK_START" ref="ab430c96f46851da92937d54104c6635eaec4a09e18e25c55cc5758202868234d5" args="" -->ON_VBLANK_START</em>&nbsp;</td><td>
<p>Start VBlank process on VBlank period, start immediatly in we are already in VBlank Start VBlank process on VBlank *start* period, means that we wait the next *start* of VBlank period if we missed it </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6433ce830019a6fc97d9b1fed7b62d4d"></a><!-- doxytag: member="sys.h::SYS_assertReset" ref="a6433ce830019a6fc97d9b1fed7b62d4d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_assertReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assert reset. </p>
<p>Assert reset pin on the 68000 CPU. This is needed to reset some attached hardware. </p>

</div>
</div>
<a class="anchor" id="abf16e3876c8375abef07da14d96d7ba9"></a><!-- doxytag: member="sys.h::SYS_die" ref="abf16e3876c8375abef07da14d96d7ba9" args="(char *err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_die </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Die with the specified error message.<br/>
 Program execution is interrupted. </p>
<p>This actually display an error message and program ends execution. </p>

</div>
</div>
<a class="anchor" id="a463232079760831964d6231a7880dfa7"></a><!-- doxytag: member="sys.h::SYS_disableInts" ref="a463232079760831964d6231a7880dfa7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_disableInts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable interrupts (Vertical, Horizontal and External). </p>
<p>This method is used to temporary disable interrupts to protect some processes and should always be followed by <a class="el" href="sys_8h.html#a3a832a0d05ffe4e856ebc3dbd53438e2" title="Re-enable interrupts (Vertical, Horizontal and External).">SYS_enableInts()</a>.<br/>
 You need to protect against interrupts any processes than can be perturbed / corrupted by the interrupt callback code (IO ports access in general but not only).<br/>
 Now by default SGDK doesn't do anything armful in its interrupts handlers (except with the <a class="el" href="struct_bitmap.html" title="Genesis 4bpp Bitmap structure definition.  Use the unpackBitmap() method to unpack if compression is ...">Bitmap</a> engine) so it's not necessary to protect from interrupts by default but you may need it if your interrupts callback code does mess with VDP for instance.<br/>
 Note that you can nest <a class="el" href="sys_8h.html#a463232079760831964d6231a7880dfa7" title="Disable interrupts (Vertical, Horizontal and External).">SYS_disableInts</a> / <a class="el" href="sys_8h.html#a3a832a0d05ffe4e856ebc3dbd53438e2" title="Re-enable interrupts (Vertical, Horizontal and External).">SYS_enableInts()</a> calls.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sys_8h.html#a3a832a0d05ffe4e856ebc3dbd53438e2" title="Re-enable interrupts (Vertical, Horizontal and External).">SYS_enableInts(void)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a753b47efe923d70d7c897a5b433efdc4"></a><!-- doxytag: member="sys.h::SYS_doVBlankProcess" ref="a753b47efe923d70d7c897a5b433efdc4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a> SYS_doVBlankProcess </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for start of VBlank and do all the VBlank processing (DMA transfers, XGM driver tempo, Joypad pooling..) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE if process was canceled because the method was called from V-Int (vertical interrupt) callback in which case we exit the function as V-Int will be triggered immediately.<br/>
</dd></dl>
<p>Do all the SGDK VBlank process.<br/>
 Some specific processing should be done during the Vertical Blank period as the VDP is idle at this time. This is always where we should do all VDP data transfer (using the DMA preferably) but we can also do the processes which has to be done at a frame basis (joypad polling, sound driver sync/update..)<br/>
 In the case of SGDK, calling this method will actually do the following tasks:<br/>
</p>
<ul>
<li>flush the DMA queue<br/>
</li>
<li>process asynchronous palette fading operation<br/>
</li>
<li>joypad polling<br/>
 <br/>
 Note that VBlank process may be delayed to next VBlank if we missed the start of the VBlank period so that will cause a frame miss. </li>
</ul>

</div>
</div>
<a class="anchor" id="abb71a9d2233dd1dda79dfeccb74c8ab5"></a><!-- doxytag: member="sys.h::SYS_doVBlankProcessEx" ref="abb71a9d2233dd1dda79dfeccb74c8ab5" args="(VBlankProcessTime processTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a> SYS_doVBlankProcessEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sys_8h.html#ab430c96f46851da92937d54104c6635e">VBlankProcessTime</a>&#160;</td>
          <td class="paramname"><em>processTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do all the VBlank processing (DMA transfers, XGM driver tempo, Joypad pooling..) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">processTime</td><td>Define at which period we start VBlank process, accepted values are:<br/>
 <b>IMMEDIATELY</b> Start VBlank process immediatly whatever we are in blanking period or not (*highly discouraged* unless you really know what you're doing !)<br/>
 <b>ON_VBLANK</b> Start VBlank process on VBlank period, if we already are in VBlank period it starts immediately (discouraged as VBlank period may be shortened and all processes cannot be completed in time)<br/>
 <b>ON_VBLANK_START</b> Start VBlank process on VBlank *start* period (recommanded as default value). That means that if <a class="el" href="sys_8h.html#a753b47efe923d70d7c897a5b433efdc4" title="Wait for start of VBlank and do all the VBlank processing (DMA transfers, XGM driver tempo...">SYS_doVBlankProcess()</a> is called too late (after the start of VBlank) then we force a passive wait for the next start of VBlank so we can align the processing with the beggining of VBlank period to ensure fast DMA transfert and avoid possible graphical glitches due to VRAM update during active display.<br/>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE if process was canceled because we forced Start VBlank process (<em>time = ON_VBLANK_START</em>) and the method was called from V-Int (vertical interrupt) callback in which case we exit the function as V-Int will be triggered immediately.<br/>
</dd></dl>
<p>Wait for Vblank and does all the SGDK VBlank process.<br/>
 Some specific processing should be done during the Vertical Blank period as the VDP is idle at this time. This is always where we should do all VDP data transfer (using the DMA preferably) but we can also do the processes which has to be done at a frame basis (joypad polling, sound driver sync/update..)<br/>
 In the case of SGDK, calling this method will actually do the following tasks:<br/>
</p>
<ul>
<li>flush the DMA queue<br/>
</li>
<li>process asynchronous palette fading operation<br/>
</li>
<li>joypad polling<br/>
 <br/>
 Note that depending the used <em>time</em> parameter, VBlank process may be delayed to next VBlank so that will wause a frame miss. </li>
</ul>

</div>
</div>
<a class="anchor" id="a3a832a0d05ffe4e856ebc3dbd53438e2"></a><!-- doxytag: member="sys.h::SYS_enableInts" ref="a3a832a0d05ffe4e856ebc3dbd53438e2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_enableInts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-enable interrupts (Vertical, Horizontal and External). </p>
<p>This method is used to reenable interrupts after a call to <a class="el" href="sys_8h.html#a463232079760831964d6231a7880dfa7" title="Disable interrupts (Vertical, Horizontal and External).">SYS_disableInts()</a>.<br/>
 Note that you can nest <a class="el" href="sys_8h.html#a463232079760831964d6231a7880dfa7" title="Disable interrupts (Vertical, Horizontal and External).">SYS_disableInts</a> / <a class="el" href="sys_8h.html#a3a832a0d05ffe4e856ebc3dbd53438e2" title="Re-enable interrupts (Vertical, Horizontal and External).">SYS_enableInts()</a> calls.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sys_8h.html#a463232079760831964d6231a7880dfa7" title="Disable interrupts (Vertical, Horizontal and External).">SYS_disableInts(void)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a00419727f141d248e171b4f66320bf2c"></a><!-- doxytag: member="sys.h::SYS_getAndSetInterruptMaskLevel" ref="a00419727f141d248e171b4f66320bf2c" args="(u16 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a> SYS_getAndSetInterruptMaskLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the interrupt mask level to given value and return previous level. </p>
<p>You can disable interrupt depending their level.<br/>
 Interrupt with level &lt;= interrupt mask level are ignored.<br/>
 We have 3 different interrupts:<br/>
 <b>Vertical interrupt (V-INT): level 6</b><br/>
 <b>Horizontal interrupt (H-INT): level 4</b><br/>
 <b>External interrupt (EX-INT): level 2</b><br/>
 Vertical interrupt has the highest level (and so priority) where external interrupt has lowest one.<br/>
 For instance to disable Vertical interrupt just use SYS_setInterruptMaskLevel(6).<br/>
</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sys_8h.html#af8f4c24b1cce2cef131d0346b4fa6d5f" title="Return current interrupt mask level.">SYS_getInterruptMaskLevel()</a> </dd>
<dd>
<a class="el" href="sys_8h.html#a810cfc8509ce88565fc002240539f9db" title="Set interrupt mask level.">SYS_setInterruptMaskLevel()</a> </dd>
<dd>
<a class="el" href="sys_8h.html#abc2725f07baaf70c775935a3878343a1" title="Set &#39;Vertical Interrupt&#39; callback method, prefer SYS_setVBlankCallback(..) when possible.">SYS_setVIntCallback()</a> </dd>
<dd>
<a class="el" href="sys_8h.html#a6804e7c1dab303971561691d0caf0d49" title="Set &#39;Horizontal Interrupt&#39; callback method (need to be prefixed by HINTERRUPT_CALLBACK).">SYS_setHIntCallback()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8d25b812d3e84e3a61a317f2494332cd"></a><!-- doxytag: member="sys.h::SYS_getCPULoad" ref="a8d25b812d3e84e3a61a317f2494332cd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a> SYS_getCPULoad </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an estimation of CPU frame load (in %) </p>
<p>Return an estimation of CPU load (in %, mean value computed on 8 frames) based of idle time spent in <a class="el" href="vdp_8h.html#a72f0d3287626224f8618a9a4a446d0f0" title="Wait for Vertical Synchro.">VDP_waitVSync()</a> / <a class="el" href="vdp_8h.html#ae7cbd2b260d6dfb844f2596b80382479" title="Wait for next Vertical Interruption.">VDP_waitVInt()</a> methods.<br/>
 The method can return value above 100% you CPU load is higher than 1 frame.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="vdp_8h.html#a72f0d3287626224f8618a9a4a446d0f0" title="Wait for Vertical Synchro.">VDP_waitVSync(void)</a> </dd>
<dd>
<a class="el" href="vdp_8h.html#ae7cbd2b260d6dfb844f2596b80382479" title="Wait for next Vertical Interruption.">VDP_waitVInt(void)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a876843c56b6ea85412f677ac34826265"></a><!-- doxytag: member="sys.h::SYS_getFPS" ref="a876843c56b6ea85412f677ac34826265" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a449a74b72ed931d627eca7efcc6f8c9d">u32</a> SYS_getFPS </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns number of Frame Per Second. </p>
<p>This function actually returns the number of time it was called in the last second.<br/>
 i.e: for benchmarking you should call this method only once per frame update. </p>

</div>
</div>
<a class="anchor" id="a8efead9cf4b059b28449895f2ad0e656"></a><!-- doxytag: member="sys.h::SYS_getFPSAsFloat" ref="a8efead9cf4b059b28449895f2ad0e656" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7470dd593b8647d2e9fcb1e94b1025c9">fix32</a> SYS_getFPSAsFloat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns number of Frame Per Second (fix32 form). </p>
<p>This function actually returns the number of time it was called in the last second.<br/>
 i.e: for benchmarking you should call this method only once per frame update. </p>

</div>
</div>
<a class="anchor" id="af8f4c24b1cce2cef131d0346b4fa6d5f"></a><!-- doxytag: member="sys.h::SYS_getInterruptMaskLevel" ref="af8f4c24b1cce2cef131d0346b4fa6d5f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a> SYS_getInterruptMaskLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return current interrupt mask level. </p>
<p>See <a class="el" href="sys_8h.html#a810cfc8509ce88565fc002240539f9db" title="Set interrupt mask level.">SYS_setInterruptMaskLevel()</a> for more informations about interrupt mask level. </p>

</div>
</div>
<a class="anchor" id="ac6cb85c35f5fac38c07c786024e15f4d"></a><!-- doxytag: member="sys.h::SYS_getShowFrameLoad" ref="ac6cb85c35f5fac38c07c786024e15f4d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a> SYS_getShowFrameLoad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns TRUE if frame load is currently displayed, FALSE otherwise. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>SYS_showFrameLoad(void) </dd></dl>

</div>
</div>
<a class="anchor" id="a5b65c43acff239a7ae711f8b14cbed0e"></a><!-- doxytag: member="sys.h::SYS_hardReset" ref="a5b65c43acff239a7ae711f8b14cbed0e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_hardReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hard reset. </p>
<p>Reset with forced hardware init and memory clear / reset operation. </p>

</div>
</div>
<a class="anchor" id="ab3b5aebd08e6d8d083de6b3b53badacd"></a><!-- doxytag: member="sys.h::SYS_hideFrameLoad" ref="ab3b5aebd08e6d8d083de6b3b53badacd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_hideFrameLoad </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hide the frame load cursor previously enabled using <a class="el" href="sys_8h.html#a7e50c065da5277fd1bf18056f89cb960" title="Show a cursor indicating current frame load level in scanline (top = 0% load, bottom = 100% load)...">SYS_showFrameLoad()</a> method. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>SYS_showFrameLoad(void) </dd></dl>

</div>
</div>
<a class="anchor" id="adb5ccb95eb2b322ea1fb80d6871b82bc"></a><!-- doxytag: member="sys.h::SYS_isInVInt" ref="adb5ccb95eb2b322ea1fb80d6871b82bc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a> SYS_isInVInt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return TRUE if we are in the V-Interrupt process. </p>
<p>This method tests if we are currently processing a Vertical retrace interrupt (V-Int callback). </p>

</div>
</div>
<a class="anchor" id="aff9750590a3aa05ba1dc9efa4529b00f"></a><!-- doxytag: member="sys.h::SYS_isNTSC" ref="aff9750590a3aa05ba1dc9efa4529b00f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a> SYS_isNTSC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return != 0 if we are on a NTSC system. </p>
<p>Better to use the IS_PAL_SYSTEM </p>

</div>
</div>
<a class="anchor" id="a7f0520edbbd126d55d6840a7c9c474e1"></a><!-- doxytag: member="sys.h::SYS_isPAL" ref="a7f0520edbbd126d55d6840a7c9c474e1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a> SYS_isPAL </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return != 0 if we are on a PAL system. </p>
<p>Better to use the IS_PAL_SYSTEM </p>

</div>
</div>
<a class="anchor" id="aadf3f1f08c7b856a150e91d8068e9d04"></a><!-- doxytag: member="sys.h::SYS_nextFrame" ref="aadf3f1f08c7b856a150e91d8068e9d04" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a> SYS_nextFrame </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>End the current frame (alias for <a class="el" href="sys_8h.html#a753b47efe923d70d7c897a5b433efdc4" title="Wait for start of VBlank and do all the VBlank processing (DMA transfers, XGM driver tempo...">SYS_doVBlankProcess(void)</a>). </p>
<p>End the current frame and does all the internal SGDK process (DMA flush, VDP data upload, async palette fade, scroll update..)</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sys_8h.html#a753b47efe923d70d7c897a5b433efdc4" title="Wait for start of VBlank and do all the VBlank processing (DMA transfers, XGM driver tempo...">SYS_doVBlankProcess(void)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5782fca78b4f2efe6c48e4103c51509"></a><!-- doxytag: member="sys.h::SYS_reset" ref="aa5782fca78b4f2efe6c48e4103c51509" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Soft reset. </p>
<p>Software reset </p>

</div>
</div>
<a class="anchor" id="aa189958e09ac6e0b5ca069cd6a99e856"></a><!-- doxytag: member="sys.h::SYS_setExtIntCallback" ref="aa189958e09ac6e0b5ca069cd6a99e856" args="(VoidCallback *CB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_setExtIntCallback </td>
          <td>(</td>
          <td class="paramtype">VoidCallback *&#160;</td>
          <td class="paramname"><em>CB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set External interrupt callback method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">CB</td><td>Pointer to the method to call on External Interrupt.<br/>
 You can remove current callback by passing a null pointer here.</td></tr>
  </table>
  </dd>
</dl>
<p>External interrupt happen on Light Gun trigger (HVCounter is locked). </p>

</div>
</div>
<a class="anchor" id="a6804e7c1dab303971561691d0caf0d49"></a><!-- doxytag: member="sys.h::SYS_setHIntCallback" ref="a6804e7c1dab303971561691d0caf0d49" args="(VoidCallback *CB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_setHIntCallback </td>
          <td>(</td>
          <td class="paramtype">VoidCallback *&#160;</td>
          <td class="paramname"><em>CB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set 'Horizontal Interrupt' callback method (need to be prefixed by HINTERRUPT_CALLBACK). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">CB</td><td>Pointer to the method to call on Horizontal Interrupt.<br/>
 You can remove current callback by passing a NULL pointer here.<br/>
 You need to prefix your hint method with <em>HINTERRUPT_CALLBACK</em>:<br/>
 </td></tr>
  </table>
  </dd>
</dl>
<p>HINTERRUPT_CALLBACK myHIntFunction() { ... } <br/>
 Horizontal interrupt happen at the end of scanline display period right before Horizontal blank.<br/>
 This period is usually used to do mid frame changes (palette, scrolling or others raster effect).<br/>
 When you do that, don't forget to protect your VDP access from your main loop using <a class="el" href="sys_8h.html#a463232079760831964d6231a7880dfa7" title="Disable interrupts (Vertical, Horizontal and External).">SYS_disableInts()</a> / <a class="el" href="sys_8h.html#a3a832a0d05ffe4e856ebc3dbd53438e2" title="Re-enable interrupts (Vertical, Horizontal and External).">SYS_enableInts()</a> otherwise you may corrupt your VDP writes. </p>

</div>
</div>
<a class="anchor" id="a810cfc8509ce88565fc002240539f9db"></a><!-- doxytag: member="sys.h::SYS_setInterruptMaskLevel" ref="a810cfc8509ce88565fc002240539f9db" args="(u16 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_setInterruptMaskLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a8aa9149a22317014c683c48cebd8cfef">u16</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set interrupt mask level. </p>
<p>You can disable interrupt depending their level.<br/>
 Interrupt with level &lt;= interrupt mask level are ignored.<br/>
 We have 3 different interrupts:<br/>
 <b>Vertical interrupt (V-INT): level 6</b><br/>
 <b>Horizontal interrupt (H-INT): level 4</b><br/>
 <b>External interrupt (EX-INT): level 2</b><br/>
 Vertical interrupt has the highest level (and so priority) where external interrupt has lowest one.<br/>
 For instance to disable Vertical interrupt just use SYS_setInterruptMaskLevel(6).<br/>
</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sys_8h.html#af8f4c24b1cce2cef131d0346b4fa6d5f" title="Return current interrupt mask level.">SYS_getInterruptMaskLevel()</a> </dd>
<dd>
<a class="el" href="sys_8h.html#a00419727f141d248e171b4f66320bf2c" title="Set the interrupt mask level to given value and return previous level.">SYS_getAndSetInterruptMaskLevel()</a> </dd>
<dd>
<a class="el" href="sys_8h.html#abc2725f07baaf70c775935a3878343a1" title="Set &#39;Vertical Interrupt&#39; callback method, prefer SYS_setVBlankCallback(..) when possible.">SYS_setVIntCallback()</a> </dd>
<dd>
<a class="el" href="sys_8h.html#a6804e7c1dab303971561691d0caf0d49" title="Set &#39;Horizontal Interrupt&#39; callback method (need to be prefixed by HINTERRUPT_CALLBACK).">SYS_setHIntCallback()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa8dccd62df36a5d1b54eb169053fbcaf"></a><!-- doxytag: member="sys.h::SYS_setVBlankCallback" ref="aa8dccd62df36a5d1b54eb169053fbcaf" args="(VoidCallback *CB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_setVBlankCallback </td>
          <td>(</td>
          <td class="paramtype">VoidCallback *&#160;</td>
          <td class="paramname"><em>CB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set user 'Vertical Blank' callback method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">CB</td><td>Pointer to the method to call on Vertical Blank period.<br/>
 You can remove current callback by passing a <em>NULL</em> pointer here.</td></tr>
  </table>
  </dd>
</dl>
<p>Vertical blank period starts right at the end of display period.<br/>
 This period is usually used to prepare next frame data (refresh sprites, scrolling ...).<br/>
 SGDK handle that in the <a class="el" href="sys_8h.html#a753b47efe923d70d7c897a5b433efdc4" title="Wait for start of VBlank and do all the VBlank processing (DMA transfers, XGM driver tempo...">SYS_doVBlankProcess()</a> method and will call the user 'Vertical Blank' from this method after all major tasks.<br/>
 It's recommended to use the 'Vertical Blank' callback instead of the 'VInt' callback if you need to do some VDP accesses.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sys_8h.html#abc2725f07baaf70c775935a3878343a1" title="Set &#39;Vertical Interrupt&#39; callback method, prefer SYS_setVBlankCallback(..) when possible.">SYS_setVIntCallback(VoidCallback *CB)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="abc2725f07baaf70c775935a3878343a1"></a><!-- doxytag: member="sys.h::SYS_setVIntCallback" ref="abc2725f07baaf70c775935a3878343a1" args="(VoidCallback *CB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_setVIntCallback </td>
          <td>(</td>
          <td class="paramtype">VoidCallback *&#160;</td>
          <td class="paramname"><em>CB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set 'Vertical Interrupt' callback method, prefer <a class="el" href="sys_8h.html#aa8dccd62df36a5d1b54eb169053fbcaf" title="Set user &#39;Vertical Blank&#39; callback method.">SYS_setVBlankCallback</a>(..) when possible. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">CB</td><td>Pointer to the method to call on Vertical Interrupt.<br/>
 You can remove current callback by passing a <em>NULL</em> pointer here.</td></tr>
  </table>
  </dd>
</dl>
<p>Vertical interrupt happen at the end of display period at the start of the vertical blank period.<br/>
 This period is usually used to prepare next frame data (refresh sprites, scrolling ...) though now SGDK handle most of these process using <a class="el" href="sys_8h.html#a753b47efe923d70d7c897a5b433efdc4" title="Wait for start of VBlank and do all the VBlank processing (DMA transfers, XGM driver tempo...">SYS_doVBlankProcess()</a> so you can control it manually (do it from main loop or put it in Vint callback).<br/>
 The only things that SGDK always handle from the vint callback is the XGM sound driver music tempo and <a class="el" href="struct_bitmap.html" title="Genesis 4bpp Bitmap structure definition.  Use the unpackBitmap() method to unpack if compression is ...">Bitmap</a> engine phase reset.<br/>
 It's recommended to keep your code as fast as possible as it will eat precious VBlank time, nor you should touch the VDP from your Vint callback otherwise you will need to protect any VDP accesses from your main loop (which is painful), use the SYS_setVIntCallback(..) instead for that.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sys_8h.html#aa8dccd62df36a5d1b54eb169053fbcaf" title="Set user &#39;Vertical Blank&#39; callback method.">SYS_setVBlankCallback(VoidCallback *CB)</a>; </dd>
<dd>
<a class="el" href="sys_8h.html#a6804e7c1dab303971561691d0caf0d49" title="Set &#39;Horizontal Interrupt&#39; callback method (need to be prefixed by HINTERRUPT_CALLBACK).">SYS_setHIntCallback(VoidCallback *CB)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a7e50c065da5277fd1bf18056f89cb960"></a><!-- doxytag: member="sys.h::SYS_showFrameLoad" ref="a7e50c065da5277fd1bf18056f89cb960" args="(bool mean)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SYS_showFrameLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#af6a258d8f3ee5206d682d799316314b1">bool</a>&#160;</td>
          <td class="paramname"><em>mean</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Show a cursor indicating current frame load level in scanline (top = 0% load, bottom = 100% load) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>frame load level display is averaged on 8 frames (mean load)</td></tr>
  </table>
  </dd>
</dl>
<p>Show current frame load using a cursor indicating the scanline reached when <a class="el" href="vdp_8h.html#a72f0d3287626224f8618a9a4a446d0f0" title="Wait for Vertical Synchro.">VDP_waitVSync()</a> / <a class="el" href="vdp_8h.html#ae7cbd2b260d6dfb844f2596b80382479" title="Wait for next Vertical Interruption.">VDP_waitVInt()</a> method was called.<br/>
 Note that internally sprite 0 is used to display to cursor (palette 0 and color 15) as it is not directly used by the <a class="el" href="struct_sprite.html" title="Sprite structure used by the Sprite Engine to store state for a sprite.  WARNING: always use the SPR_...">Sprite</a> Engine but if you're using the low level VDP sprite methods then you should know that sprite 0 will be used here.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="sys_8h.html#ab3b5aebd08e6d8d083de6b3b53badacd" title="Hide the frame load cursor previously enabled using SYS_showFrameLoad() method.">SYS_hideFrameLoad(void)</a> </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ab41d8358de9da304b45a9cd847cb03cd"></a><!-- doxytag: member="sys.h::addressErrorCB" ref="ab41d8358de9da304b45a9cd847cb03cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoidCallback* <a class="el" href="sys_8h.html#ab41d8358de9da304b45a9cd847cb03cd">addressErrorCB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Address error interrupt callback. </p>
<p>You can modify it to use your own callback (for debug purpose). </p>

</div>
</div>
<a class="anchor" id="a61bbd6b4f07f82f9bd611ef58721eef1"></a><!-- doxytag: member="sys.h::busErrorCB" ref="a61bbd6b4f07f82f9bd611ef58721eef1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoidCallback* <a class="el" href="sys_8h.html#a61bbd6b4f07f82f9bd611ef58721eef1">busErrorCB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bus error interrupt callback. </p>
<p>You can modify it to use your own callback (for debug purpose). </p>

</div>
</div>
<a class="anchor" id="abf6b1b9a2bfea27af8214110dc17a46b"></a><!-- doxytag: member="sys.h::chkInstCB" ref="abf6b1b9a2bfea27af8214110dc17a46b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoidCallback* <a class="el" href="sys_8h.html#abf6b1b9a2bfea27af8214110dc17a46b">chkInstCB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>CHK instruction interrupt callback. </p>
<p>You can modify it to use your own callback (for debug purpose). </p>

</div>
</div>
<a class="anchor" id="af2a592696b5e90e63bf969d555d66cbf"></a><!-- doxytag: member="sys.h::errorExceptionCB" ref="af2a592696b5e90e63bf969d555d66cbf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoidCallback* <a class="el" href="sys_8h.html#af2a592696b5e90e63bf969d555d66cbf">errorExceptionCB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Error exception callback. </p>
<p>You can modify it to use your own callback (for debug purpose). </p>

</div>
</div>
<a class="anchor" id="ac850e8b90e9b259160ffb52963981df8"></a><!-- doxytag: member="sys.h::illegalInstCB" ref="ac850e8b90e9b259160ffb52963981df8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoidCallback* <a class="el" href="sys_8h.html#ac850e8b90e9b259160ffb52963981df8">illegalInstCB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Illegal instruction exception callback. </p>
<p>You can modify it to use your own callback (for debug purpose). </p>

</div>
</div>
<a class="anchor" id="a46c6198d4926288b16793833d2ddc89a"></a><!-- doxytag: member="sys.h::intCB" ref="a46c6198d4926288b16793833d2ddc89a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoidCallback* <a class="el" href="sys_8h.html#a46c6198d4926288b16793833d2ddc89a">intCB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Level interrupt callback. </p>
<p>You can modify it to use your own callback. </p>

</div>
</div>
<a class="anchor" id="a202e800a4fe6f8f9072d8a22847bb5d0"></a><!-- doxytag: member="sys.h::line1x1xCB" ref="a202e800a4fe6f8f9072d8a22847bb5d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoidCallback* <a class="el" href="sys_8h.html#a202e800a4fe6f8f9072d8a22847bb5d0">line1x1xCB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="struct_line.html" title="Line definition.">Line</a> 1x1x exception callback. </p>
<p>You can modify it to use your own callback (for debug purpose). </p>

</div>
</div>
<a class="anchor" id="a5038c44f538391d4f31be0a59c7c3462"></a><!-- doxytag: member="sys.h::privilegeViolationCB" ref="a5038c44f538391d4f31be0a59c7c3462" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoidCallback* <a class="el" href="sys_8h.html#a5038c44f538391d4f31be0a59c7c3462">privilegeViolationCB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Privilege violation exception callback. </p>
<p>You can modify it to use your own callback (for debug purpose). </p>

</div>
</div>
<a class="anchor" id="ab2ad43e595f0a19f7a8431dc2a7d8de5"></a><!-- doxytag: member="sys.h::traceCB" ref="ab2ad43e595f0a19f7a8431dc2a7d8de5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoidCallback* <a class="el" href="sys_8h.html#ab2ad43e595f0a19f7a8431dc2a7d8de5">traceCB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trace interrupt callback. </p>
<p>You can modify it to use your own callback (for debug purpose). </p>

</div>
</div>
<a class="anchor" id="ac391fc51fd8d14f9fa49df15659dfe82"></a><!-- doxytag: member="sys.h::trapvInstCB" ref="ac391fc51fd8d14f9fa49df15659dfe82" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoidCallback* <a class="el" href="sys_8h.html#ac391fc51fd8d14f9fa49df15659dfe82">trapvInstCB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TRAPV instruction interrupt callback. </p>
<p>You can modify it to use your own callback (for debug purpose). </p>

</div>
</div>
<a class="anchor" id="a182faeee80f45228cb08a9a934a293d3"></a><!-- doxytag: member="sys.h::zeroDivideCB" ref="a182faeee80f45228cb08a9a934a293d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoidCallback* <a class="el" href="sys_8h.html#a182faeee80f45228cb08a9a934a293d3">zeroDivideCB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Division by zero exception callback. </p>
<p>You can modify it to use your own callback (for debug purpose). </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="sys_8h.html">sys.h</a>      </li>
      <li class="footer">Generated on Thu Jul 27 2023 23:19:56 for sgdk by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
